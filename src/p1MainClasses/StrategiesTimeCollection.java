package p1MainClasses;

public class StrategiesTimeCollection {

	
	
	
	
	


//int size=initialSize; 
//size<=finalSize; size+=incrementalSizeStep) { 
//    // For each strategy, reset the corresponding internal variable that will be used to store the sum 
//    // of times that the particular strategy exhibits for the current size size.
//    for (StrategiesTimeCollection<Integer> strategy : resultsPerStrategy) 
//        strategy.resetSum();    // set to 0 an internal instance variable used to accumulate sum of times
//			
//    // Run all trials for the current size. 
//    for (int r = 0; r<repetitionsPerSize; r++) {
//        // The following will be the common dataset to be used in the current trial by all the strategies being
//        // tested. Here, that data set is generated by a method that gets as input (parameter values): n, m, size. 
//        // Where n and m are the number of companies and number of crime events, respective. The generated
//        // must satisfy: size  =  i=1nj=1m(dataset[i][j].length)
//        Integer[][][] dataset = generateData(n, m, size);  
//
//        // Apply each one of the strategies being tested using the previous dataset (of size size) as input; 
//        // and, for each, estimate the time that the execution takes.
//        for (StrategiesTimeCollection<Integer> strategy : resultsPerStrategy) {	
//            long startTime = System.nanoTime();  // Measure system’s clock time before.
//            strategy.runTrial(dataset);          // Run the strategy using the data in dataset.        
//            long endTime = System.nanoTime();    // Measure system’s clock time after.
//
//                           int estimatedTime = (int) (endTime-startTime);   // The estimated time.
//            // Accumulate the estimated time (add it) to sum of times that the current strategy has 
//            // so far accumulated  on the previous trials for datasets of the current size. 
//            strategy.incSum(estimatedTime);    				
//        }
//    }
//    // For each strategy, compute the average time for the current size.	
//    for (StrategiesTimeCollection<Integer> strategy : resultsPerStrategy)
//        strategy.add( new AbstractMap.SimpleEntry<Integer, Float>
//                          (size, (strategy.getSum()/((float) repetitionsPerSize)))
//                    ); 
//}
//
//	
//	
	
	
}
